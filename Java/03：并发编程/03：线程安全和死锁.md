---
title: 线程安全和死锁
abbrlink: 10492
date: 2020-07-09 23:37:42
categories:
  - Java
  - 并发
---

# 什么是线程安全？

当多个线程修改同一个共享变量的时候，如果对该变量修改的结果不能确定，那么称：**该变量线程不安全**。

比如这个例子：

```java
public class Task implements Runnable {

    // 共享变量
    static int num = 0;

    @Override
    public void run() {
        // 对共享变量的修改
        for (int i = 0; i < 100_000; i++) {
            num++;
        }
    }

    public static void main(String[] args) {
        final Thread t1 = new Thread(new Task());
        final Thread t2 = new Thread(new Task());
        t1.start();
        t2.start();
        while (t1.isAlive() || t2.isAlive()) { }
        System.out.println("num = " + num);
    }
}
```

显然最后的打印结果不会跟预期结果一样，两个线程同时对一个变量 num 做十万次 ++ 操作，最后的结果 num 应该是等于二十万才对。

但是上面的程序最终结果都是在 [100_000, 200_000] 这个区间内的，显然与预期结果不符。

为什么不符合预期，其实原因很简单：

> 上面代码 `num++` 的这行语句在执行的时候是有三个步骤的，如下：
> 1. 将 num 的值读到缓存中
> 2. 将 num 的值加1
> 3. 将 num 的值写回内存

上述例子中，两个线程同时都在执行 `num++` 的操作，也就是同时在执行这三个步骤，如果 t1 和 t2 同时都执行了第1步，拿到 num 的值为`1`；再往下执行第二步，t1 和 t2 都把 num 的值从`1`加到`2`；最后 t1 和 t2 再把 num 的值写回内存，此时 num 的值为`2`。

但也有不出错的情况，那最后 num 的结果就是`3`，num 最后的值具体是`2`还是`3`不好确定，所以称变量 num 线程不安全。

**num 的范围：**

既然 num 变量线程不安全，但也总是会有一个范围，这个范围由执行出错的“次数”维护。

最大值：如果每次执行都没出错，结果都是确定的两个线程都成功加`1`，那结果就是 `num = 200,000`，也就是上述这个例子中num的最大值。

最小值：相反如果每次执行都出错了，两个线程的执行结果总是只保存了一个下来，那结果就是 `num = 100,000`，也就是上述这个例子中num的最小值。

# 怎样才能线程安全？