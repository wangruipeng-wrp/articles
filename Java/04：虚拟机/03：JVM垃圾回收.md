---
title: JVM 垃圾回收
abbrlink: 23073
date: 2022-11-05 01:11:10
description: 在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”。
---

# 对象已死？

在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（“死去”即不可能再被任何途径使用的对象）了。

## 引用计数算法

在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。

**优点：**原理简单，判断效率高。
**缺点：**无法解决循环引用问题。

## 可达性分析算法

通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。

![利用可达性分析算法判断对象是否可回收](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/利用可达性分析算法判断对象是否可回收.png)

### GC Roots 对象

**固定对象：**

- 栈帧中的本地变量表中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
- 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
- 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
- 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
- 所有被同步锁（synchronized关键字）持有的对象。
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

**临时性对象：**

如果只针对 Java 堆中的某一块区域发起垃圾回收，必须考虑到内存区域并不是封闭独立的所以某个区域里的对象完全有可能被位于堆中其他区域的对象所引用，这时候就需要将这些关联区域的对象也一并加入GC Roots集合中去，才能保证可达性分析的正确性。

### finalize()

可以用来做外部资源回收的工作，但是 try-finally 可以做的更好，并且 finalize() 方法执行效率低、执行成本高、不确定性大，所以一般不推荐使用，仅作了解。

真正宣告一个对象死亡，要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记。随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。

这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。

如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。

```java
/**
* 此代码演示了两点：
* 1.对象可以在被GC时自我拯救。
* 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次
* @author zzm
*/
public class FinalizeEscapeGC {
    public static FinalizeEscapeGC SAVE_HOOK = null;
    public void isAlive() {
        System.out.println("yes, I am still alive :)");
    }
    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("finalize method executed!");
        FinalizeEscapeGC.SAVE_HOOK = this;
    }
    public static void main(String[] args) throws Throwable {
        SAVE_HOOK = new FinalizeEscapeGC();
        //对象第一次成功拯救自己
        SAVE_HOOK = null;
        System.gc();
        // 因为Finalizer方法优先级很低，暂停0.5秒，以等待它
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println("no, I am dead :(");
        }
        // 下面这段代码与上面的完全相同，但是这次自救却失败了
        SAVE_HOOK = null;
        System.gc();
        // 因为Finalizer方法优先级很低，暂停0.5秒，以等待它
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println("no, I am dead :(");
        }
    }
}
```

## 四大引用类型

### 强引用

最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似 `Object obj=new Object()` 这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。

```java
Object obj = new Object();
```

### 软引用

用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null; // 使对象只被软引用关联
```

### 弱引用

用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。

```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null; // 使对象只被弱引用关联
```

### 虚引用

最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj);
obj = null; // 使对象只被虚引用关联
```

# 垃圾收集算法

## 标记-清除算法

首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。

**缺点：**
1. 效率不稳定，效率随着需要被回收的对象的增多而降低。
2. 内存空间碎片化，会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

![“标记-清除”算法示意图](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/“标记-清除”算法示意图.png)

## 标记-复制算法

将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

**优点：**对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。

**缺点：**将可用内存缩小为了原来的一半。

![标记-复制算法示意图](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/标记-复制算法示意图.png)

现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。

HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。

## 标记-整理算法

标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。

![“标记-整理”算法示意图](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/“标记-整理”算法示意图.png)

`标记-清除`算法与`标记-整理`算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策：

- **移动：**移动操作必须全程暂停用户应用程序才能进行
- **不移动：**存活对象所导致的内存碎片化问题

是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂

> 有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。

# 经典垃圾收集器

## 分代收集理论

“分代收集”（Generational Collection）的理论建立在两个分代假说之上：

- 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。
- 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。

*分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则。*

这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：**收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。**

> 显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。

设计者一般至少会把Java堆划分为新生代（Young Generation）和老年代（Old Generation）两个区域。顾名思义，在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。

但是分代收集并非只是简单划分一下内存区域那么容易，它至少存在一个明显的困难：**对象不是孤立的，对象之间会存在跨代引用。**为了解决这个问题，就需要对分代收集理论添加第三条经验法则：

- 跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。

依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GCRoots进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。

## 垃圾收集器图示

![HotSpot虚拟机的垃圾收集器](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/HotSpot虚拟机的垃圾收集器.png)

图展示了七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用，图中收集器所处的区域，则表示它是属于新生代收集器抑或是老年代收集器。

## Serial 收集器

![SerialSerial Old收集器运行示意图](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/SerialSerialOld收集器运行示意图.png)

这个收集器是一个单线程工作的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。

**优点：**简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。
**缺点：**在进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。

**适用场景：**对于内存资源受限的环境，它是所有收集器里额外内存消耗（Memory Footprint）最小的；对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。

## ParNew 收集器

![ParNewSerial Old收集器运行示意图](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/ParNewSerialOld收集器运行示意图.png)

它是 Serial 收集器的多线程版本。

是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。

默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。

## Parallel Scavenge 收集器

Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）

Parallel Scavenge收集器ᨀ供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。

**-XX：MaxGCPauseMillis：**参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过用户设定值。但垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的。

**-XX：GCTimeRatio：**参数的值则应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。譬如把此参数设置为19，那允许的最大垃圾收集时间就占总时间的5%（即1/(1+19)），默认值为99，即允许最大1%（即1/(1+99)）的垃圾收集时间。

## Serial Old 收集器

![SerialSerial Old收集器运行示意图](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/SerialSerialOld收集器运行示意图.png)

Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。在服务端模式下有两大用途：

1. 在 JDK 1.5 以及之前版本(Parallel Old 诞生以前)中与 Parallel Scavenge 收集器搭配使用。
2. 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

## Parallel Old 收集器

Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

![Parallel ScavengeParallel Old收集器运行示意图](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/ParallelScavengeParallelOld收集器运行示意图.png)

## CMS 收集器

> CMS（Concurrent Mark Sweep）收集器是一种基于**标记-清除**算法实现的，以获取**最短回收停顿时间**为目标的收集器。**优点：**并发收集、低停顿。

**整个运作过程分为四步：**

1. **初始标记：**仅仅只是标记一下GC Roots能直接关联到的对象，速度很快
2. **并发标记：**从GC Roots的直接关联对象开始遍历整个对象图，耗时较长但是不需要停顿用户线程
3. **重新标记：**修正在并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录
4. **并发清除：**使用标记-清除算法清理删除掉标记阶段判断的已经死亡的对象，不需要移动存活对象

由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。

![ConcurrentMarkSweep收集器运行示意图](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/ConcurrentMarkSweep收集器运行示意图.png)

**四个缺点：**

1. 与用户线程并发执行期间，会占用一部分线程而导致应用程序变慢而降低总吞吐量
2. 款基于“标记-清除”算法实现，收集结束时可能会有大量空间碎片产生
3. 无法清理浮动垃圾：在CMS的并发标记和并发清理阶段，用户线程是还在继续运行，会有新的垃圾对象产生。这部分垃圾就称为“浮动垃圾”，只能等下一次垃圾清楚再回收
4. 需要预留空间：由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器必须预留一部分空间供并发收集时的程序运作使用

## Garbage First 收集器

Garbage First（简称G1）收集器主要面向服务端应用，目标是建立一个可预测的时间停顿模型，就是可以由用户来指定每次回收停顿多长时间。但指定的时间如果很短，那每次也只能回收少量垃圾，并且还会增加回收次数，甚至由于每次只回收少量垃圾，可能会引发 Full GC 反而降低性能。通常把期望停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的。

基于这个目标，G1 追求的是满足应用内存的分配需求，而不追求一次性回收所有的内存垃圾。于是传统的内存布局模型就不太适合 G1 了，因为每次新生代或者老年代回收的区域都比较固定，也就没办法预测每次内存回收所耗费的时间。所以 G1 开创了收集器面向局部收集的设计思路和基于 Region 的内存布局形式。

### Region 内存布局

G1不以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。

虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的动态集合。G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1 还会为每个 Region 维护一个回收成本，之后在每次回收计算出由哪些 Region 组成回收集可以在不超过期望停顿时间的约束下获得最高的收益。

Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。

**G1收集器Region分区示意图：**

![G1收集器Region分区示意图](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/G1收集器Region分区示意图.png)

### Region 里面的跨代引用问题



### G1收集器的运作过程



## ZGC 收集器



# JVM 内存分配与回收策略

---

> **巨人的肩膀：**
> - 《深入理解Java虚拟机》