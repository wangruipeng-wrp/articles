---
title: JavaScript：执行上下文
abbrlink: 54687
date: 2020-05-29 20:56:46
categories:
 - JavaScript
---

执行上下文是js中很重要的一个概念，每次当js程序去调用一个函数时，就会去创建一个对应的执行上下文。我们可以先将执行上下文理解为当前代码执行的环境，这会产生一个作用域的概念，也就是我的上一篇文章所提到的。js引擎会销毁该函数的执行上下文。js程序在执行时每次遇到函数时都会做这样的操作。
<!-- more -->

# 一、执行上下文生命周期
首先我们还是来对执行上下文有一个深入的了解，当一个函数被调用时，一个对应的执行上下文就会被创建。而一个执行上下文的生命周期可以分为两个阶段。**创建阶段**和**执行阶段**
- **创建阶段**
在这个阶段中，执行上下文会分别创建**变量对象**，建立**作用域链**，以及确定**this**的指向。这些概念接下来都会仔细的说一下。
- **执行阶段**
创建完成之后，开始逐行的执行代码。这个时候会完成变量赋值、函数引用、以及执行其他代码。

# 二、区别执行上下文和变量作用域
在上一篇文章重提到了一个作用域的概念。作用域与执行上下文都是在函数的中的概念，可能会有点冲突，导致理解起来容易混淆，这里有必要区别一下这两个概念。

执行上下文是在函数调用时才去动态的创建，因为不同的调用可能会是完全不同的参数。而变量作用域则是在函数声明时就确定了，跟函数的调用无关，函数在调用时只会去创建执行上下文。相比较而言，变量作用域更像是一个静态的概念，在函数声明时就确定下来的，函数内部的变量只能存活于这个作用域之中，不管是什么样的变量只要是在函数的内部去声明的，就肯定是跑不出函数的作用域中。（这里插一句：函数的参数也是函数的内部变量，存活于函数的作用域之中）而执行上下文呢则是在调用时才会产生的，甚至是在某种特殊的环境下会产生多个执行上下文，例如闭包。

**举个例子吧：**
> 我们平时开的汽车，当这辆汽车被生产出来的时候，其中的功能就已经是确定的了，比如最高能达到多高的时速、最多能坐几个人、能载重多少重量等等，这相当于是确定了作用域。但是在我们实际的使用的时候由于路面环境的不同、用途不同、司机不同等等的原因导致这辆汽车发挥出来的效果也是不用。这就相当于是每次执行的时候都创建了对应的执行上下文。
>
> **上面的例子可能有些不太恰当的地方，仅代表个人的理解**

# 三、执行上下文栈
在js中函数的调用是有严格的先后顺序的，在一个js程序中正在执行的函数有且仅有一个，另外的函数想要执行必须等待当前函数执行完毕后按照顺序排队执行。如果是一个函数中包含了另外一个函数的执行的话那么需要在执行到**被包含的函数**中时去执行**被包含的函数**，等待被包含的函数**执行完毕**之后才可以继续接着执行下面的内容。这样的执行顺序天然的符合“**栈**”这种后入先出的数据结构。我们来看一个例子：
```js
function fn() {
    console.log("fn函数开始执行");
    fn2();
    console.log("fn函数执行完毕");
}

function fn2() {
    console.log("fn2函数开始执行");
    console.log("fn2函数执行完毕");
}

fn();
```
> **在上面的这段代码中，js引擎首先创建了一个全局的执行上下文。**
将这个全局执行上下文压入执行上下文栈中。此时的栈结构：`栈底 -> 全局 -> 栈顶`
**之后开始执行代码，当执行到第12行调用了`fn`函数的时候，去创建了一个`fn`的执行上下文。**
将`fn`的执行上下文再压入栈。此时的栈结构：`栈底 -> 全局 -> fn -> 栈顶`
**开始执行`fn`函数中的代码。执行到第3行的时候调用了`fn2`，这个时候会去创建一个`fn2`的执行上下文。**
将`fn2`压入栈。此时的栈结构：`栈底 -> 全局 -> fn -> fn2 -> 栈顶`
**之后开始执行`fn2`的内容，当函数`fn2`执行完毕之后，销毁`fn2`的执行上下文。**
销毁执行上下文就是将该上下文弹出栈，此时弹出`fn2`后的栈结构：`栈底 -> 全局 -> fn -> 栈顶`
**再继续执行函数`fn`中剩余的部分，当函数`fn`执行完毕之后销毁了函数`fn`的执行上下文。**
弹出`fn`，此时的栈结构：`栈底 -> 全局 -> 栈顶`
**等到关闭浏览器窗口的时候会去销毁全局的执行上下文。**
此时的栈结构：`栈底 ->  ->栈顶`

上面的这个例子很形象的阐述了函数调用栈是如何去管理执行上下文的执行顺序的。每次在调用函数的时候会去创建一个执行上下文，并将其压入栈顶。而执行的时候也是只执行位于栈顶的函数，执行完毕后将栈顶的函数弹出栈，再接着执行栈顶的函数。按照这个顺序去执行，到最后就只剩下一个全局的执行上下文，关闭浏览器窗口后把最后一个全局上下文弹出栈，之后调用栈为空，也意味着程序执行完毕。

# 四、作用域链
**我们先来看一段代码：**
```js
var name = "全局的name";
var name1 = "全局的name1";
var name2 = "全局的name2";

function fn() {

    var name = "fn的name";
    var name1 = "fn的name1";

    function fn2() {

        var name ="fn2的name";

        console.log(name);  // 输出fn2的name
        console.log(name1); // 输出fn的name1
        console.log(name2); // 输出全局的name2
    }

    fn2();
}

fn();
```
这段代码中，很清晰的向我们展示了什么是作用域链。在函数`fn2`的内部去输出`name`这个变量，首先是在当前函数的作用域也就是`fn2`的执行上下文中去寻找`name`这个变量，找到了之后直接输出。如果找不到，例如变量`name1`的这种情况，则会去上一级的作用域中去寻找，也就是函数`fn`的作用域，找到后再输出。如果还是找不到，例如变量`name2`的情况，那么就会再到上一级的作用域中去寻找，找到后再输出。一级一级的网上去寻找形成了一个链式的操作，称之为**作用域链**。

**分析作用域链的形成**
> 结合一下前文提到过的函数调用栈的概念，一级一级网上去查找变量的这个过程，其实就是在函数调用栈中去一级一级的往栈底的执行上下文去查找。也就是说作用域链是在函数调用栈中由栈顶的执行上下文去往栈底的执行上下文去一级一级的链起来形成的作用域链。

# 五、变量对象（Variable Object，VO）
变量对象无非也是一个对象，对象就是为了承载数据而存在的。所以变量对象就是一些数据的载体，只是这个对象我们并不能够去实际的创建出来，看不见摸不着而已。

## 变量对象的创建
1. 建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。
2. 检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。
3. 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。这里牵扯到一个变量提升的概念，面试常考。

## 变量提升
变量提升这个概念其实很好理解，在一个js程序中，使用`var`关键字声明的变量会在程序执行时提前去**声明**。仅此而已。我们再来看看js程序是如何去声明一个变量的。`var name;`这样就声明了一个变量名为`name`的变量。这么声明一个变量的话，变量的值毫无疑问就是一个`undefined`。总结一下就是：js引擎将使用`var`声明的变量赋值为`undefined`放在了程序开始执行的第一步去做了。这个概念就这么简洁明了的解释清楚了。

**变量提升的作用：**
那为什么js引擎要做这个变量提升的事情呢，这个主要还是为了节约CPU开销去考虑的一个事情，因为声明变量是需要去在内存中开辟出一块空间来存放这个变量的。这个动作是比较耗费CPU资源的一个动作，如果在程序中大量的去执行这个动作的话，毫无疑问会对程序执行的效率造成一定的影响。所以将这一类的操作，全部提前一次性的给他完成了，以这样的方式来提升程序的执行效率。

**我们结合一个例子来更加清楚的理解一下这个概念：**
```js
console.log(a); // 输出undefined
var a = 10;
```
这是一个简单的例子，很好的展现了变量提升这个概念。首先在全局作用域中，js引擎去搜索了所有`var`声明的变量，然后在当前的这个作用域中提前声明，再逐行执行代码。也就是说上面的这段代码实际上是下面的这个样子的。
```js
var a;
console.log(a); // 输出undefined
a = 10;
```
这么看来就毫无疑问输出一个`undefined`了。

## window对象
介绍一个很重要的对象，`window`对象，这是一个内置的全局对象，之所以说这个对象很重要呢是因为我们所声明的一些全局变量都是这个对象下的属性，我们所写的方法也是这个对象的方法。

我个人其实更愿意将这个`window`对象理解为一个特殊的**变量对象**（一个全局的变量对象）我们来分析一下变量对象在创建的时候都做了什么和`widnow`对象都有什么。
1. 首先创建变量对象的第一步是：建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。
    `window`对象做为一个全局的对象，并没有参数传递进来，自然也就没有这一步。
2. 然后第二步是：检查当前执行上下文中的函数声明，在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。
    这一步在`window`对象中是有体现的，因为在js程序中声明的全局函数都是可以直接通过`window`对象去直接`.`的调用的。而且`window`对象还为我们内置了许多的方法可以直接调用，不需要自己手动的去写，封装了一些更方便的工具方法。
3. 最后第三步是：检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。
    我们在声明全局的变量时其实就是在声明一个`window`对象的属性。

**来看一些简单的例子：**

```js
var name = "zhangsan";
function fn() {
    console.log("fn");
}
console.log(window.name === name); // 输出true
window.fn(); // 输出fn
```
在这个例子中，定义的全局变量或者是方法，都可以使用`windwow`去`.`一下调用出来。甚至是一个没有定义的变量，也可以使用`window`对象去`.`出来。在上面作用域的哪个例子中如果使用`window`对象去调用变量`name1`的话是不会报错的。我们来看一下：
```js
var name = "zhangsan";
function fn() {
    var name1 = "lisi";
    console.log(name);
}
console.log(name);   // 输出zhangsan
console.log(window.name1);  //输出undefined
fn();  // 输出zhangsan
```
我们再来看一个例子，然后分析一下这个`window`对象
```js
var name;
console.log(name);  // 输出undefined

conosle.log(window.name1);  // 输出undefined
```
**注意：上面这个例子需要在IE浏览器中运行才会出效果**
> 以上是我的一些个人看法，如果有不对的地方，还请在评论区直接指出。

## 活动对象（Activation Object，AO）
前文提到的变量对象在执行上下文的**创建阶段**被创建出来，但是这个时候我们是没办法去访问变量对象里面的属性的。
但是在执行上下文的**创建阶段**结束后进入**执行阶段**时，变量对象会转变成为活动对象。这是就可以访问里面的属性了。
所以，实际上变量对象和活动对象是同一个对象，只是处于执行上下文生命周期的不同阶段而已。

# 六、this关键字

## 定义
首先要说明的一点是：`this`并不是在定义函数的时候确定的，前文提过，一个执行上下文在创建的阶段最重要的三件事之中其中之一就是确定`this`的指向，所以`this`是在执行上下文创建的时候才会去指定的。而执行上下文有全局的还有函数的，因此`this`可以被剖析为全局的`this`和函数的`this`。
实际上，如果在一个对象中去定义了一个函数的话，其实是将这个函数在堆内存中声明了一下，再去赋值给对象中的属性，所以在调用这个对象的这个函数的属性的时候其实并不一定是在同一个作用域下去调用的，针对不同的作用域，`this`的指向也就不同。

我们来看一个例子加深理解：
```js
var name = 'zhangsan';
  
var obj = {
  name: 'lisi',
  fn: function() {
    console.log(this.name);
  },

  subObj: {
    fn: function() {
      console.log(this.name);
    }
  }
};

obj.fn(); // 输出lisi
obj.subObj.fn() // 输出undefined

var say = obj.subObj.fn;
say(); // 输出zhangsan
```
在上面这个例子中，三个`this`分别指向三个不同的对象。

第一个`obj.fn()`直接由`obj`对象调用，指向的是`obj`对象。

第二个`obj.subObj.fn()`由`obj`对象去调用了`subObj`对象，再由`subObj`对象去调用了`fn`方法，所以实际上是`subObj`对象去调用了`fn`方法，所处的也就是`sub`对象的作用域之中，自然指向的也就是`sub`对象了。

第三个`say`对象是由`obj.subObj.fn`对象赋值而来的，而`say`对象又是处于全局的作用域下，所以在这里虽然是声明了一个`obj.subObj.fn`对象，但是所处的作用域确实一个全局作用域，指向的也就是全局中的`window`对象。

上面这个例子很好的诠释了`this`这个关键字在不同情况下指向的是完全不同的对象。**谨记一点`this`关键字是在调用时才能够确定指向的**。

### 全局中的this
全局中的`this`对象非常简单，就是指向了上文提到的`window`对象，也就是说任何在函数外部的`this`都是指向了`window`对象。
例如：
```js
console.log(this === window) // 输出true
```
上面这个例子中，直接在全局中比较`this`对象和`window`对象，结果为true。充分证明了在全局环境中，`this`指向的就是`window`对象。

### 函数中的this
1. **普通函数**
```js
function fn() {
    console.log(this);
}

fn(); // 输出Window
```
这个很好理解，`fn()`处于一个全局作用域中由`window`对象直接调用，所以`this`指向的是`window`对象本身。

2. **构造函数**
```js
function Fn() {
    this.name = 'zhangsan';
}

var a = new Fn();
console.log(a.name); // 输出zhangsan
```
任何使用`new`关键字创建出来的都是一个对象，是一个在**堆内存**中的对象，所以在这里`this`指的是新创建的这个对象。