---
title: 学会2-3树，其实红黑树一点都不难
abbrlink: 18972
date: 2021-07-18 14:15:42
categories: 数据结构
---

好了，终于来到了这块最难啃的骨头了——**红黑树**。

首先，当然是直接摆出红黑树大名鼎鼎的五条基本性质了

1. <font color=blue>节点是红色或者黑色。</font>
2. <font color=blue>根节点是黑色。</font>
3. <font color=blue>所有叶子节点都是黑色。（叶子节点是空节点）</font>
4. <font color=blue>不存在能够和两条红链接相连的节点。（每个红色的节点的两个子节点都是黑色）</font>
5. <font color=blue>从任意一个节点到叶子节点，经过的黑色节点数量是一样的。（黑平衡）</font>

只要满足以上五个性质的二叉搜索树就可以称之为红黑树。

<!-- more -->

> 温馨提示：本文比较长，开始之前还请你耐下心来，一步一步仔细看完，我相信这篇文章会带给你一些收获。继续加油！：）

红黑树其实也是一种二叉搜索树，只不过这是一种性能更好的二叉搜索树。二叉搜索树的结构决定了增删改查这些操作对于二叉搜索树而言都是对数级别的时间复杂度，所以这是一种高效的数据结构，但它有一个致命的缺陷，就是有序插入元素的情况下，它会严重的向一边倾斜退化成一个链表，也就是所谓的失衡。所以，我们希望我们的二叉搜索树在任何情况下都能保持左图的样子，或者说是尽量保持成左图的样子，而永远不要退化成右图的样子。于是我们为二叉搜索树加入了平衡机制，其中红黑树就是这么一种机制。**对于二叉搜索树的有序性而言，红黑树在这基础上又添加了平衡性。**以上红黑树的五条基本性质就是维持平衡的手段。

![20210720231008](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20210720231008.png)

像左图这样的树我们称之为平衡的，而红黑树仅仅只是维持平衡的手段而已，<font color=blue>红黑树在本质上依然是一棵二叉搜索树。</font>

像红黑树这样的数据结构，肯定也不是一朝一夕能够发明出来的，而是有一个演化的过程，从二叉搜索树到红黑树之间就有一个不可缺少的过渡——**2-3查找树**。

# 2-3查找树
<br>

**定义：**
- 一棵2-3查找树要么是一棵空树，要么由`2-节点`和`3-节点`组成。
- `2-节点`：含有一个节点本身的值和两条链接，左连接指向的2-3树值都小于该节点，右链接指向的2-3树值都大于该节点。
- `3-节点`：含有两个节点本身的值和三条链接，左连接指向的2-3树值都小于该节点，中链接指向的2-3树值都位于节点的两个值之间，右链接指向的2-3树值都大于该节点。

**注意：**
- 2-3查找树是一种完美平衡的树结构，也就是说一棵2-3树中的任意节点的左子树、中子树、右子树高度相等。

**由完美平衡可知：**
- `2-节点`要么没有两条链接都指向空，要么两条链接都不为空。
- `3-节点`要么没有三条链接都指向空，要么三条链接都不为空。

**如图：**
![album_temp_1627184547](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/album_temp_1627184547.PNG)

> **接下来将分析2-3树中的各种插入情况**

## 向2-节点添加元素

首先，需要在2-3树中搜索到一个可以添加节点的位置，如果搜索结束于一个`2-节点`，那么很好办，只需要将这个`2-节点`替换成一个`3-节点`。像这样：
![IMG_0045](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/IMG_0045.PNG)

---

其实向一个`2-节点`插入元素是非常简单的，只需要将一`2-节点`变换成一个`3-节点`即可。但是这很简单的一步却是保持2-3树完美平衡**最关键的一步**。

试想一个问题：一棵完美的平衡二叉树，也就是满二叉树，它的节点个数是奇数还是偶数？答案非常简单，是奇数，根节点的左子树和右子树的节点数是相同的，于是整棵树的节点数就是`2 * 左子树的节点数 + 1`。采用递归的思想，整棵树无论对于哪个节点求节点个数得出的答案都是奇数。

于是，如果一棵二叉树的节点个数是偶数，那么这棵二叉树绝对不是完美平衡，想要得到一棵完美平衡的二叉树必备的一个条件就是树的节点个数为奇数。实际上一棵完美平衡的二叉树的节点数是等于`2 ^ h - 1`的。（其中h为树的高度，根节点的高度为1）

一棵二叉树在生成的过程当中，依次将元素插入其中，这不可能保证整棵树的节点个数在任何情况下都是奇数。事实上，在节点只能存放一个元素的情况下，不可能实现完美平衡的树结构。2-3树中的`3-节点`正是为了解决这一情况而存在的。

正常情况下，向二叉树中的一个左右子树都为空的节点插入元素无论插入在左子树还是右子树中肯定会造成这个节点的不完美平衡，但是现在引入了`3-节点`这样的一个过渡的节点，说白了，这其实是在暂存一下这种不平衡的情况，一旦在这个`3-节点`中再次插入一个元素之后立马会分裂成为一棵左右子树都不为空的二叉树。

## 向3-节点添加元素

单纯的向一棵仅有一个三节点的2-3树添加元素是比较简单的，这里简单讲一下思路即可。

1. 将新节点插入`3-节点`中，组成一个临时的`4-节点`。此时这个`4-节点`中包含三个值和四条链接。
2. 将这个`4-节点`的三个值都抽取出来成为三个`2-节点`，中值抽取出来的`2-节点`作为根，根的左链接指向三个节点中的最小者，右链接指向三个节点中的最大者。

![album_temp_1627305570](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/album_temp_1627305570.PNG)

> 也许有些同学也注意到了，这一步操作使得树的高度增加了，在将`4-节点`分裂为三个`2-节点`的过程当中，树高由1变成了2。这也是2-3树的生长方式，当根节点已经是一个`3-节点`的时候插入一个新的节点，此时根节点分裂为三个`2-节点`，树高度加1。与普通的二叉查找树不同的是2-3树的生长方向是由下至上生长的，而二叉查找树的生长方向是由上至下生长的。

### 向一个父节点为2-节点的3-节点添加元素

1. 插入到`3-节点`中，组成一个临时的`4-节点`。
2. 将`4-节点`的中值所抽取出来的根节点插入至父节点，使父节点从原来的`2-节点`变成`3-节点`
    此处插入过程与“向`2-节点`添加元素”相同。
3. 将`4-节点`分裂出来的两个`2-节点`移动至父节点中，成为`3-节点`的两个子树。

![album_temp_1627307311](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/album_temp_1627307311.PNG)

### 向一个父节点为3-节点的3-节点添加元素

1. 插入到`3-节点`中，组成一个临时的`4-节点`。
2. 将`4-节点`的中值抽取出来的根节点插入至父节点，使父节点从原来的`3-节点`变成一个临时的`4-节点`。
3. 将`4-节点`分裂出来的两个`2-节点`移动至父节点也就是新的临时的`4-节点`中，成为新的临时`4-节点`的两个子树。
4. 将新的临时的`4-节点`分裂出来的根继续往上插入
    此处插入的过程与“向一个父节点为`2-节点`的`3-节点`添加元素”相同。

![album_temp_1627307543](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/album_temp_1627307543.PNG)

### 向“从插入节点出发直到根节点全部都是3-节点”的节点添加元素

1. 一直按照“向一个父节点为`3-节点`的`3-节点`添加元素”的方式插入元素，那么直到最后根节点也会变成一个临时的`4-节点`。
2. 将根节点转换成的临时`4-节点`分裂开来，按照“向`3-节点`添加元素”的方式，中值成为整颗2-3树新的根，此时树高加一。

![album_temp_1627310222](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/album_temp_1627310222.PNG)

---

**以上就是2-3树中插入元素的全部情况，做个小结：**
1. 向`2-节点`插入元素：直接插入至`2-节点中`生成一个三节点。
2. 向`3-节点`插入元素：
    1. 父节点为`2-节点`：组成临时`4-节点`，分裂后的根插入父节点组成`3-节点`。
    2. 父节点为`3-节点`：组成临时`4-节点`，分裂后的根插入父节点，再次组成临时`4-节点`。
        不断重复此过程，直到找到一个`2-节点`为止。如果直到根节点还找不到，则将根节点分裂成三个`2-节点`，此时树高加一。


# 红黑树

其实我更愿意这么来理解红黑树：<font color=blue>使用二叉树来表现2-3树</font>。换句话说，其实2-3树和红黑树是等价的。

> 其实一般的红黑树是等价于2-3-4树的，也就是我们前面说的2-3树中再加了一个`4-节点`。但是本文讲述的红黑树是左倾红黑树，具体的左倾红黑树与一般红黑树的区别，在这就留个坑吧。在这里只需要记住一点：**左倾红黑树中红链接全部都是左连接**。

一棵2-3树中的`2-节点`跟二叉查找树中的节点是完全相同的，也就是说普通的节点就可以表示2-3树中的`2-节点`。于是我们只要能够使用二叉树的形式来表现一个`3-节点`我们就可以成功的将一棵2-3树转化成为红黑树。

将`3-节点`中的两个值分别当作是两个`2-节点`分裂开，中间使用一条连接将这两个`2-节点`相连接起来，表示了这两个`2-节点`代表了一个`3-节点`。这样的链接被称为红链接。

![album_temp_1627903082](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/album_temp_1627903082.PNG)

为了方便表示红链接我们注意到每个红色链接都会指向唯一的一个节点，所以我们将节点标记为红色来表示指向此节点的链接是红链接，相反的没有被红链接指向的节点全部就被标记为黑色。

本文一开始就提出的红黑树的五条基本性质中的第1点、第2点、第3点也就是这么来的，性质4和性质5稍微有一些抽象：

1. <font color=blue>节点是红色或者黑色</font>：每个节点都会被标记为红色或者黑色。
2. <font color=blue>根节点是黑色</font>：二叉树中没有链接指向根节点，所以根节点被标记为黑色。
3. <font color=blue>所有叶子节点都是黑色</font>：叶子节点都是空节点，没有被红链接所指向，所以标记为黑色。
4. <font color=blue>不存在能够和两条红链接相连的节点</font>：如果将红黑树中由红链接相连的节点合并起来，得到的就是一棵2-3树。相反，如果将一棵2-3树中的`3-节点`画作由红色左连接相连的两个`2-节点`，那么肯定不会存在能够和两条红链接相连的节点。
5. <font color=blue>从任意一个节点到叶子节点，经过的黑色节点数量是一样的。</font>：如果将红链接画平，那么第5点将很容易理解。

![album_temp_1627905396](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/album_temp_1627905396.PNG)

> 上图中粗链接表示为红链接

## 着色和旋转

保持红黑树五大性质的两大法宝就是着色和旋转，其中旋转又分为左旋转和右旋转。

### 着色
着色操作比较简单，只需要改变对节点颜色的标记即可。

### 左旋转和右旋转

下图中粗链接表示为红链接
![20210803095327](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20210803095327.png)

具体的旋转过程在[AVL 树](https://www.wrp.cool/posts/54793/)这篇文章中已经有具体的说明。这里不再过多的赘述。

> 需要注意的是：旋转过后应该保持根节点颜色相同，以及这里的旋转过程是在插入节点时调用的，在2-3树中插入操作总是和树中的节点相互融合的，所以要将旋转后的节点标记为红色。

<!-- TODO 聊清楚左右旋转的着色原理 -->

---

在正式开始插入操作之前，有一点需要先注意：新插入的节点默认是红色的节点，因为在插入的时候除非是插入在根节点的位置之外，所有的插入首先都是与原有的节点做融合操作，而融合进其他节点的节点在红黑树中被标记为红色。

## 向红黑树中的“2-节点”插入元素

向一个`2-节点`中插入元素之后，会与原来的`2-节点`一起形成一个`3-节点`。这就引申出了两种情况：

1. 插入节点小于`2-节点`，插入在`2-节点`的左边，成为`2-节点`的左孩子。
    符合左倾红黑树的定义，即红链接在左边，此时无需修改。
2. 插入节点大于`2-节点`，插入在`2-节点`的右边，成为`2-节点`的右孩子。
    不符合左倾红黑树的定义，即红链接在右边，此时需要对被插入节点做一次左旋转的操作，以将右红链接纠正为左红链接。

![album_temp_1628078520](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/album_temp_1628078520.PNG)

## 向红黑树中的“3-节点”插入元素

向一个`3-节点`中插入元素之后，与原来的`3-节点`之间会产生三种情况：

1. 插入的元素小于`3-节点`的两个元素。
2. 插入的元素位于`3-节点`的两个元素之间。
3. 插入的元素大于`3-节点`的两个元素。

![album_temp_1628079653](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/album_temp_1628079653.PNG)

> 注意：以上的三种情况中最后的一个步骤都是需要将根节点也就是b节点转换成黑色的，这样才能保持红黑树的第五条性质，黑平衡。

## 插入代码实现

```java
public class RBTree {

    private static final boolean RED = true;
    private static final boolean BLACK = false;

    private static class Node {
        int e;
        Node left, right;
        boolean color;

        public Node(int e) {
            this.e = e;
            this.left = null;
            this.right = null;
            this.color = RED;
        }
    }

    private Node root;
    private int size;

    /**
     * 左旋转
     */
    private Node leftRotate(Node node) {
        // 暂存
        Node x = node.right;

        // 旋转
        node.right = x.left;
        x.left = node;

        // 着色
        x.color = node.color;
        node.color = RED;

        return x;
    }

    /**
     * 右旋转
     */
    private Node rightRotate(Node node) {
        // 暂存
        Node x = node.left;

        // 旋转
        node.left = x.right;
        x.right = node;

        // 着色
        x.color = node.color;
        node.color = RED;

        return x;
    }

    private boolean isRed(Node node) {
        return node == null ? BLACK : node.color;
    }

    private void flipColors(Node node) {
        node.color = RED;
        node.left.color = BLACK;
        node.right.color = BLACK;
    }

    public void add(int e) {
        add(root, e);
        root.color = BLACK;
    }

    private Node add(Node node, int e) {
        if (node == null) {
            size++;
            return new Node(e);
        }

        if (node.e > e) {
            node.left = add(node.left, e);
        }
        if (node.e < e) {
            node.right = add(node.right, e);
        }

        if (isRed(node.right) && !isRed(node.left))
            node = leftRotate(node);

        if (isRed(node.left) && isRed(node.left.left))
            node = rightRotate(node);

        if (isRed(node.left) && isRed(node.right))
            flipColors(node);

        return node;
    }
}
```

> 本文中的参考图片出自《算法：第4版》这本书中的红黑树章节。