---
title: 数据结构：链表
abbrlink: 29990
date: 2020-08-02 14:45:27
categories:
 - 数据结构
---

# 前言
如果上一篇文章实现的动态数组，由于底层任然是使用的静态数组，而不是真正意义上的**动态数据结构**的话。那么本文的链表则肯定是一个真真正正意义上的动态的数据结构了。
<!-- more -->
我还记得在读书时老师曾经给我们举过一个非常好的例子用于演示链表和数组在增删改查种各自的优缺点。在这里我把它分享出来给大家
> 一个班级假设有50个学生，现在使用数组和链表来分别承载这50个学生。
然后模拟两种场景来分别对比这两种数据结构的优缺点
**数组：**将这50个学生按照顺序排号，从0开始到49（这里模拟的是数组的下标）
***像这样 [0, 1, 2, 3, ..., 49]***
**链表：**将50个学生叫到操场排好队，每个学生去记住自己后面一个学生，记录排第一的同学（链表头）。
***像这样 (0) -> (1) -> (2) -> (3) -> ... -> (49)***
原谅我懒得画图。。。

**场景一：**老师在办公室想要叫某个学生到办公室去（模拟数据的查询）
**数组：**直接在班级表种去查这个学生对应的序号，根据序号就可以很快速的找到这个学生。
**链表：**由于没有序号，需要一个个学生去查找，首先找到链表头同学，比较是不是老师叫的学生，如果是则去办公室找老师。如果不是，则去找链表头同学所记住的后面一个同学，再进行对比。如果还不是则再去寻找这个同学记忆的下一个同学之后再进行比对，直到找到这个同学为止。

**场景二：**班上来了一个新的插班生，插班生必须安排在班级的第一个位置（模拟数据的添加和删除）
**数组：**由于每个学生的序号都是按照顺序排好的，所以不能直接插入在第一个学生之前，必须是要占用第一个学生的位置。所以要将全部的学生重新排号，插班生排0号，剩下的学生按照原来的号码依次加1往后排序。
**链表：**让这个插班生去记住第一个同学也就是原理啊的链表头，再成为新的链表头。其他的学生完全不受影响。

通过以上两个场景的展现可以很清晰的看出来链表和数组各自的优缺点在哪里。链表增删快，而数组查询快。

# 设计节点类
链表中的数据实际上是一个个的节点，在Java中使用一个节点类（Node）来表示。在节点类中有两个变量，一个是当前节点的值，另一个是指向下一个节点的指针。
由此每个节点中都有一个指向下一个节点的指针，最后一个节点指向下一个节点的指针就置为空。以此一节一节的链接起来，也就成了链表。
```java
private class Node {
    // 节点本身的值（支持泛型）
    public E e;
    // 指向下一个节点的指针
    public Node next;

    // 构造方法
    public Node(E e, Node next) {
        this.e = e;
        this.next = next;
    }
    public Node(E e) { this(e, null); }
    public Node() { this(null, null); }

    @Override
    public String toString() { return e.toString(); }
}
```

# 设计链表的成员变量和构造方法
我们先来考虑一下怎么去设计链表类中的成员变量再来看看怎么设计构造函数

首先我们需要一个变量可以表示当前链表中共有多少个节点，也就是链表的大小。size变量是没跑了。
另外回顾一下刚刚的例子，在哪个班级中如果老师需要找到一个班级中的某个确定的学生时，第一个找的其实是链表头同学，根据链表头去一个个找下去直到找到为止。
所以在我们设计的链表类中需要一个头节点的指针，定义一个**Node变量**作为指针。

刚刚的例子中场景二来一个插班生我们将插班生插在了第一个位置。直接让插班生去记住原来的链表头再将链表头指向插班生。设想一下，如果是插入在链表的中间呢？
比如插入在第二个学生的位置。需要插班生去记住原来的第二个同学，再让原来的第一个同学把记忆的第二个同学换成插班生同学。也就是说如果是插入在中间的元素要多一步让前面的同学去记插班生同学，而插入在第一个则不需要。

针对上面的情况我们可以设置一个虚拟的头节点来解决这个问题。这个虚拟的节点来指向我们链表中真正的第一个节点，对外呢，屏蔽这个节点的存在。故此我们将上面决定要定义的**Node变量**改成**dummyHead**

```java
private int size;
private Node dummyHead; // 虚拟头节点

// 构造方法
public LinkedList() {
    dummyHead = new Node(null, null);
    size = 0;
}

// 方便用户传入一个数组将其转换成链表的构造方法
public LinkedList(E[] arrayE) {
    dummyHead = new Node(null, null);
    size = arrayE.length;

    Node cur = dummyHead;
    for (int i = arrayE.length - 1; i >= 0; i--) {
        cur.next = new Node(arrayE[i], cur.next);
    }
}

// 设计两个方便使用的方法
public int getSize() { return size; }
public boolean isEmpty() { return size == 0; }
```

# 链表中插入元素
我们来研究一下前面的例子是怎么在一个班级中插入插班生的。

> 首先，得要有一个插班生，这个不用想肯定是必须的，好了，插入功能核心代码的**第一步**也就出来了。
然后我们得要去找到插班生要插入的位置，在这里呢我们虚拟一个index（下标）的概念出来，方便用户指定要插入的位置，核心功能的**第二步**也就出来了。
找到位置也有插班生之后的问题就是要把插班生插入到班级里面去啦，这个事情要怎么做呢。
比方说我现在是要插入到第二个位置去，那么我需要先让插班生去记忆原来的第二个位置的同学，这也是**第三步**。
然后让第一个同学不要去记原来的第二个同学了，换成是插班生同学，**第四步**。
到此为止，这个插入的动作就完成了。

将上面的各个步骤以程序的方式重新梳理一遍
第一步：创建一个新的节点 `new Node()`
第二步：使用一个for循环找到要插入位置的前一个节点和后一个节点
第三步：将第一步创建出来的节点的`next`指针指向第二步找出来的后一个节点
第四步：将第二步找出来的前一个节点的`next`指针指向第一步创建的节点

将上面的逻辑组织一下换成Java语言
```java
public void add(E e, int index) {
    // 下标的校验，不属于插入的核心代码
    if (index < 0 || index > size) {
        throw new IllegalArgumentException("index " + index + " 不合法, 当前size = " + size);
    }

    // 第一步
    Node node= new Node(e);

    // 第二步：
    // 使用一个prev变量去作为一个中间量去寻找要插入的节点位置
    // 这里的prev就是前一个节点，由于还没有插入，所以prev.next就是要插入的后一个节点
    Node prev = dummyHead;
    for (int i = 0; i < index; i++) {
        prev = prev.next;
    }

    // 第三步
    node.next = prev.next;

    // 第四步
    prev.next = node;

    // 维护一下size变量
    size++;
}
```
以上便是添加操作的方法，但这还不是最好。

上面的代码虽说是完成了这个添加动作的逻辑，也能够顺顺利利的运行起来，但这还不够优雅。
实际上我们可以将第一步、第三步和第四步合并成一行代码
创建一个新的节点直接将`prev.next`赋值给新节点的`next`，再直接赋值给`prev.next`。
像下面这个样子
```java
public void add(E e, int index) {
    if (index < 0 || index > size) {
        throw new IllegalArgumentException("index " + index + " 不合法, 当前size = " + size);
    }

    Node prev = dummyHead;
    for (int i = 0; i < index; i++) {
        prev = prev.next;
    }

    // 原来的第一步、第二步和第四步
    prev.next = new Node(e, prev.next);
    size++;
}
```

---
> 插一句题外话
其实编写程序，就是像上面这样子一步一步去考虑出这个程序核心代码的步骤。
然后再把这个简单的按照程序逻辑梳理一遍，再开始实际编码。也恰恰是这两步才是最关键的，而不是编码，有了梳理完的逻辑实际编码起来码随心动倒还是个挺舒服的过程。
最后再审视一遍自己写出来的代码，看看有没有地方可以改进，可以写的更加的优雅一些
---

# 删除链表中的元素
我们来换个方式写删除操作，在前面的添加操作中我们设置了一个虚拟的index表示的是下标，作用是方便用户操作。在删除的这一小节我们不使用这个index我们假设用户能够直到自己要删除的元素，直接传入待删除元素，然后程序将其删除即可。

删除元素实际上就是添加元素的逆向操作，找到待删除节点的前一个节点，将这个节点直接指向待删除元素的后一个节点即可删除。

```java
public void remove(E e) {
    // 找到要删除元素的前一个元素
    Node prev = dummyHead;
    while(!prev.next.e.equals(e)) {
        prev = prev.next;
    }

    // 将要删除元素前一个元素的指针直接指向要删除元素的后一个元素
    prev.next = prev.next.next;

    size--;
}
```

将上面的代码使用递归的方式写出来
```java
public void remove(E e) {
    remove(e, dummyHead);
}
private void remove(E e, Node node) {
    if (node.next.e.equlas(e)) {
        node.next = node.next.next;
        size --;
        return;
    }
    remove(e, node.next);
}
```
实际上链表这样的数据结构天然的适合递归，在很多场合都可以使用递归去操作一个链表。