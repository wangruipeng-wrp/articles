---
title: 快速排序
abbrlink: 11306
date: 2021-06-16 22:32:13
description: 本来像是这样的排序算法在网上搜个快速排序能找到很多的博客在详细的说明快速排序的实现、特点、性能、时间复杂度等等，但还是决定要自己写一篇博客来讲讲这个算法，实际上是想要分享一些在学习这个算法的过程中一些让我感到惊讶的地方。
categories:
  - 算法
  - 排序算法
---

本来像是这样的排序算法在网上搜个快速排序能找到很多的博客在详细的说明快速排序的实现、特点、性能、时间复杂度等等，但还是决定要自己写一篇博客来讲讲这个算法，实际上是想要分享一些在学习这个算法的过程中一些让我感到惊讶的地方。

<font color=blue>也正是因为这样的一些比较独特的，比较不可思议却又是合乎情理的存在才让算法变得更神秘，更吸引人了。</font>

<!-- more -->

---

先简单的讲一下快速排序的核心思想：
> 每次在数组中随机的找到一个元素，以这个元素为基准将整个数组分成大于基准元素的部分和小于基准元素的部分，之后再按照小于基准元素、基准元素、大于基准元素这样的顺序排好，之后再递归的对小于基准元素部分和大于基准元素部分分别进行相同的操作。有一些书中也会将这个基准元素称为标兵。

根据这样的一个思想我们可以很快速的设计出第一版的快速排序：
```java
public void sort(int[] arr, int l, int r) {
    if (l >= r) return;
    
    int j = l;
    for (int i = l + 1; i <= r; i++) {
        if (arr[i] < arr[l]))
            swap(arr, i, ++j);
    }
    swap(arr, l, j);

    sort(arr, l, j - 1);
    sort(arr, j + 1, r);
}

// 此处swap函数用于交换数组中两个下标处的值。
```

有些书上的快速排序实现的过程可能跟上面代码并不一致，这里也想说一点关于自己的想法，对于算法的实现我们更应该关注的是这个算法的思想，以及我们所实现的算法的时间复杂度分析上，而不是去纠结具体实现的方式。

上面的代码看着好起来并不复杂，但是想要彻底的理解的话其实并不容易，关键是要能够理解 j 代表什么，也就是 j 的语义。

<font color=blue>此处的 j 代表了小于标兵元素部分的最右边的元素。</font>

> 上面的代码对于初学者可能并不是特别友好，如果你有任何的疑问欢迎在评论区提问。

---

**有意思的地方现在开始了：**

如果你觉得上面的代码没问题的话，在这里强烈建议你设计一个数据规模是百万这个级别并且已经排好序的数组来跑一下上面的这个快速排序算法，你会发现这一点也不快速。

由于我们每次所选择的标兵元素都是数组中的第一个元素，所以如果是一个已经排好序的数组，这个快速排序算法会直接退化成一个`O(n^2)`级别的算法。

改进的方式是使用随机标兵，于是上面的代码迎来了第一次改进。

```java
public void sort(int[] arr, int l, int r) {
    if (l >= r) return;

    // 随机标兵（针对有序数组的优化）
    swap(arr, l, l + random.nextInt(r - l + 1));
    
    int j = l;
    for (int i = l + 1; i <= r; i++) {
        if (arr[i] < arr[l]))
            swap(arr, i, ++j);
    }
    swap(arr, l, j);

    sort(arr, l, j - 1);
    sort(arr, j + 1, r);
}
```

代码的逻辑还是没有改变，还是选取数组中的第一个元素为标兵元素，但是在每次选取之前将数组中的第一个元素和数组中的随机任何一个元素交换一下位置，以达到随机标兵的效果。

---

但就算是这样这个算法依旧不完美，设想一下：**如果是一个所有元素都相同的数组呢？**
比如一个容量为一百万的数组里面存放的元素全部都是0。

如果是这样的情况，那么随机标兵也就没有作用了，快速排序也就再次退化成了一个`O(n^2)`级别的算法。

于是第二次改进：**双路快速排序**
```java
private void sort(int[] arr, int l, int r) {
    if (l >= r) return;

    // 随机标兵（针对完全有序数组所进行的优化）
    swap(arr, l, l + random.nextInt(r - l + 1));

    int i = l + 1, j = r;
    while (true) {
        while (arr[i] < arr[l]) i++;
        while (arr[j] > arr[l]) j--;

        if (i >= j) break;
        swap(arr, i++, j--);
    }
    swap(arr, l, j);

    sort(arr, l, j - 1);
    sort(arr, j + 1, r);
}
```

---

双路快速排序算法已经是一个可以满足所有场景的快速排序算法了。

但是这还不够完美，还是刚刚的例子，如果数组中全部元素都相同的话，虽然可以满足O(nlogn)这个级别的速度实现排序，但是如果全部元素都相同的话快速排序还可以做到O(n)级别的时间复杂度。

于是最终版本：**三路快速排序**
```java
private <T extends Comparable<T>> void sort(T[] arr, int l, int r) {
    if (l >= r) return;

    // 随机标兵（针对完全有序数组所进行的优化）
    SortingHelper.swap(arr, l, l + random.nextInt(r - l + 1));

    int lt = l, i = l + 1, gt = r + 1;
    while (i < gt) {

        if (arr[i].compareTo(arr[l]) < 0) 
            SortingHelper.swap(arr, ++lt, i++);

        else if (arr[i].compareTo(arr[l]) > 0) 
            SortingHelper.swap(arr, i, --gt);

        else
            i++;
    }
    SortingHelper.swap(arr, l, lt);

    sort(arr, l, lt - 1);
    sort(arr, gt, r);
}

```