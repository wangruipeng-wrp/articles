<h1>一条SQL更新语句是如何执行的？</h1>

> [《极客时间-MySQL实战45讲》02 | 日志系统：一条SQL更新语句是如何执行的？](https://time.geekbang.org/column/article/68633) 的笔记

- [重要日志模块：redo log](#重要日志模块redo-log)
- [重要的日志模块：binlog](#重要的日志模块binlog)
  - [两种日志的不同点：](#两种日志的不同点)
  - [两阶段提交](#两阶段提交)

与上一篇笔记中的查询流程相同，一条更新语句也是要经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎。

例如这样的一个表，然后有这样的一条更新的语句
```sql
mysql> create table T(ID int primary key, c int);
mysql> update T set c=c+1 where ID=2;
```

在上一篇笔记中说过在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表 T 上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。

但与查询流程所不相同的是，更新流程涉及到两个重要的日志模块：redo log（重做日志）和binlog（归档日志）。

# 重要日志模块：redo log

其实就是 MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging（预写日志记录），它的关键点就是先写日志，再写磁盘。

> 需要注意的是：redo log 也是在磁盘里的，并不是保存在内存里。

**redo log工作流程：**

1. 当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log 里面。
2. 更新内存，将这条记录的最新值放到内存里。
3. 之后 InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。

**干嘛要搞的这么复杂，直接写磁盘不好吗？**

- **直接写磁盘？？** 那不是每次都要去找要写在哪里，数据那么多，等找出来不是人都麻了。
- **那redo log不也是写磁盘？？** redo log是在磁盘中单独开辟出来的一块空间写滴，每次要写就在后面追加写上去就完了，不用每次都去找要写在哪里，等有空了再去找写在哪里然后写进去，省去了一个寻址的操作。 **顺序写可比随机写快的多的多**

**还有个事儿，redo log的大小是固定的哇！！！**

> 换句话说就是长江后浪推前浪，前浪被拍死在沙滩上哇！！前浪都被后浪卷死了哇！！！

看图吧您！！

![redo_log循环写示意图](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/redo_log循环写示意图.jpg)

write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。就像是循环数组一样。

**讲这么多，redo log干嘛的哇？？** 用来搞哪个crash-safe的哇！！

> 有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。
> 
> redo log是将未提交的数据写入磁盘，不是写入内存，因此如果数据库异常重启了，那么InnoDB也可以通过读取redo log来重新恢复那些未提交的事务。这样的能力称之为crash-safe

# 重要的日志模块：binlog

> **为什么有了redo log还需要binlog？**
>
> 上一篇笔记中说过 MySQL 整体来看，其实就有两块：一块是 Server 层，负责 MySQL 功能层面的事情，另外一块是引擎层，负责存储相关的具体事宜。redo log 只是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。
> 
> 因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。

## 两种日志的不同点：
1. redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。

2. redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。

3. redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

**binlog的工作流程：**

1. 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。

2. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。

3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，**此时 redo log 处于 prepare 状态。**

4. 然后告知执行器执行完成了，随时可以提交事务。执行器生成这个操作的 binlog，并把 binlog 写入磁盘。

5. 执行器调用引擎的提交事务接口， **引擎把刚刚写入的 redo log 改成提交（commit）状态** ，更新完成。

整个执行流程示意图（图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。）
![binlog执行流程示意图](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/binlog执行流程示意图.jpg)

最后的三步将redo log的写入分成了两个部分，prepare和commit 这就是“两阶段提交”

## 两阶段提交

两阶段提交是为了保证两个日志的一致性设计的。

**假设没有两阶段提交，会怎样？**

- **先提交redo log：** （提交完MySQL挂掉）
    - 重启恢复：redo log 比 binlog 多出一条数据，
        - 如果后续拿 binlog 做备份恢复，则丢失该条数据
        - 如果此时拿 binlog 做一个从库复制，则从库比主库少了该条数据

- **先提交binlog：** （提交完MySQL挂掉）
    - 重启恢复：使用redo log恢复，此时 binlog 比库中多了一条数据记录
        - 如果后续拿 binlog 做备份恢复，会莫名多出来一条数据（该记录未曾提交）
        - 如果此时拿 binlog 做一个从库复制，则从库比主库多了该条数据

**有了两阶段提交之后呢？**

两阶段提交流程：1. prepare 阶段、2.写 binlog、3. commit
    - 在2之前崩溃：发现没有 commit 且两份日志不统一，自动回滚。两份日志一致
    - 在3之前崩溃：虽然没有 commit 但是两份日志统一，自动提交。两份日志一致
    - 备份：全靠 binlog

---

> 网友热心总结的一些问题，复习的时候可以试着回答一下。
1. redo log的概念是什么? 为什么会存在.
2. 什么是WAL(write-ahead log)机制, 好处是什么.
3. redo log 为什么可以保证crash safe机制.
4. binlog的概念是什么, 起到什么作用, 可以做crash safe吗? 
5. binlog和redolog的不同点有哪些? 
6. 物理一致性和逻辑一直性各应该怎么理解? 
7. 执行器和innoDB在执行update语句时候的流程是什么样的?
8. 如果数据库误操作, 如何执行数据恢复?
9. 什么是两阶段提交, 为什么需要两阶段提交, 两阶段提交怎么保证数据库中两份日志间的逻辑一致性(什么叫逻辑一致性)?
10. 如果不是两阶段提交, 先写redo log和先写bin log两种情况各会遇到什么问题?

大家加油：）