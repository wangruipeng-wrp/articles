<h1>深入浅出索引</h1>

> 《极客时间-MySQL实战45讲》[04 | 深入浅出索引（上）](https://time.geekbang.org/column/article/69236)、[05 | 深入浅出索引（下）](https://time.geekbang.org/column/article/69636) 的笔记

- [索引的常见模型](#索引的常见模型)
  - [哈希表](#哈希表)
  - [有序数组](#有序数组)
  - [N叉树](#n叉树)
- [InnoDB 的索引模型](#innodb-的索引模型)
- [索引维护](#索引维护)
- [覆盖索引](#覆盖索引)
- [最左前缀原则](#最左前缀原则)
- [索引下推](#索引下推)

首先还是要先了解 **页（Page）** 这个概念，才能更好的理解 InnoDB 中的索引。

**页是什么？**

- 页（Page）是 InnoDB 中管理数据的最小单元。
- 聚簇索引中的叶子结点就是一个个的页。

> *插句题外话：之前初学 MySQL 的时候，由于 DML 操作的都是一行行的数据，所以那时候总是以为 MySQL 中的最小数据单位就是行。UPDATE 的时候就去磁盘中拿到对应的数据出来，然后 UPDATE 之后再放回去。但现在看来显然不是，MySQL 是先把该行数据所在的页先加载到内存中修改完了再延迟刷回磁盘的。*

**页的概览**

MySQL 中的数据最终都是存在聚簇索引树的叶子结点中的，页之间是双向链表的这么一种数据结构，页与页之间也是有序的。在叶子结点中存储用户数据的部分是一种单向链表的结构。

当我们在查找数据的时候，为了快速判断要查找的数据是否在当前页之中。在页中还会记录页本页用户数据中的最大值和最小值。

如果所需要的数据就在当前页中，为了避免整个页去查找，MySQL 又在页中加入了另一个区域 Page Directory 目录，里面有很多个槽位（Slots），每一个槽位都指向了一条 User Records 中的记录。每隔几条数据，就会创建一个槽位。在一个完整的页中，每隔6条数据就会有一个 Slot。有了 Page Directory 之后，页内的用户数据就不需要去维护有序性了，直接插入在链表尾部即可。

Slot 会在新增数据的时候创建和维护，之后就可以对一张页的数据进行 **粗略** 的二分查找。因为二分查找出来的结果只能是个大概的位置，找到了这个大概的位置之后，还需要回到 User Records 中继续的进行挨个遍历匹配。

> 粗略画了下页的概览图，如下：

![1654781897359](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/1654781897359.png)

> **小结：** MySQL 查找数据的方式，首先是通过索引将数据所在的页先加载到内存中去，之后在内存中尽量的缩小所在数据的范围，再去遍历数据找到最终所需要的数据。
> **参考自** [MySQL 页完全指南——浅入深出页的原理](https://zhuanlan.zhihu.com/p/382375842)

---

# 索引的常见模型

三种常见、也比较简单的数据结构，它们分别是`哈希表`、`有序数组`和`N叉树`

> 你心里要有个概念，数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。

## 哈希表

哈希表是一种以 `键 - 值（key-value）` 存储数据的结构，我们只要输入待查找的键即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。如果多个 key 值经过哈希函数的换算，出现了同一个值。这种情况称为哈希冲突，一般可以往后拉出来一个链表解决。

- **优点：**
    - 新增数据快，可以直接查询到要添加的位置，直接添加或者添加为链表的尾结点。
    - 等值查询速度快。
- **缺点：**
    - 由于无序，所以哈希索引做区间查询的速度是很慢的。 
- **适用场景：**
    - 只有等值查询的场景。

## 有序数组

是一种数组按照下标升序或者降序存储数据的结构。

- **优点：**
    - 使用二分法做查询速度很快，时间复杂度是 O(log(N))
    - 支持区间查询，先用二分法查询到区间最左的元素，再向右遍历直至最又的元素。
- **缺点：**
    - 往中间添加一个数据需要往后挪动所有的数据，这个过程很慢，时间复杂度是 O(log(N))
- **适用场景：**
    - 有序数组只适用于读多写少的情况。

## N叉树

为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。

以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。

**InnoDB 引擎中使用的是 B+树 这种N叉树的数据结构作为索引模型。**

# InnoDB 的索引模型

在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。准确的说应该是存在 B+ 树中的叶子节点中的。每个叶子节点就是开头说的**页（Page）**。

每一个索引在 InnoDB 里面都对应了一棵 B+ 树。根据叶子节点的内容，索引类型分为主键索引和非主键索引。主键索引的叶子节点存的是整行数据。

- 在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。
- 非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。

**基于主键索引和普通索引的查询有什么区别？**

- 如果语句是 select * from T where ID=1，即主键查询方式，则只需要搜索 ID 这棵 B+ 树
- 如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的具体值，再到 ID 索引树搜索一次。这个过程称为 **回表**。

也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。

**为什么普通索引的叶子节点上要存放的是 ID，为什么不直接存对应行数据的地址呢？**

- **优点：**
    减少了页分裂或者页合并时候二级索引的维护工作。
- **缺点：**
    1. 二级索引体积可能会变大，因为其中存储了主键信息。
    2. 二级索引的访问需要两次查找，要多一次回表的操作。

**一个老生常谈的话题了，为啥不用 `select *`，而要把查询的字段全部写出来呢？**

`select *` 是肯定要回表的，会导致索引覆盖用不了。

# 索引维护

前文说过 InnoDB 页之间是有序的，为了维护这个有序性，在插入新值和删除旧值的时候就需要做一些必要的维护。

> 有个概念可能会混淆，得先说清楚。索引是肯定有序的，这里的有序无序指的是插入的顺序没有按照从小到大的顺序插入。

如果都是有序插入的话，每次都直接在页内插入一条新的数据或者申请一个新的页再插入数据即可，这样子可以保证除了最后一页所有页都是满的，空间利用率最高。有序插入的方案是最优的，自增主键就是一种 InnoDB 提供的有序插入的方案。

**页分类与页合并：**

- **页分裂：**

如果无序插入到一个页内空间已经满了的话，就需要再开新的一页来存储这个数据。根据 B+ 树的算法，会挪动部分数据过去新的页，这个过程称为**页分裂**。在这种情况下，性能自然会受影响。除了性能外，页分裂操作还影响数据页的利用率。因为新开的数据页不一定会被填满。

- **页合并：**

当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。

**两个建议：**

1. 使用自增主键。这样可以保证每次插入都是有序插入的，可以防止页分裂。
2. 删除先做逻辑上的删除，不要做物理删除，这样可以防止页合并。等到有时间了再去真正的删除。

新增或者删除的时候多了分裂或者合并的操作，性能自然会受到影响。除了考虑性能外，从存储空间的角度来看，也应该用自增主键，因为普通索引的叶子节点上存储的是主键，显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。

# 覆盖索引

由于二级索引并没有存放真实的数据，所以需要到主键索引上进行一次回表的操作，这自然会影响性能。

那如果我只要查 ID 呢？二级索引的叶子节点上就是记录了 ID，那么自然不需要回表，自然提高了性能。于是很自然的一个想法就出现了，那就是把一些经常会查询到的字段一起记录在二级索引上，这就是**覆盖索引**。

由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。

> 比如有这样的一个需求：**根据身份证号码查询姓名**
> 
> 身份证号码作为每个人的唯一标识，肯定会有很多根据身份证号码查询身份信息的请求，应该要在身份证号码这个字段上建一个索引。但查询姓名这个需求是一个很高频的需求，这个时候就可以把身份证号码跟姓名一起建立一个联合索引。这样它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。

当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。

# 最左前缀原则

假设现在有一个（姓名，年龄）的联合索引：

![最左前缀索引](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/最左前缀索引.jpg)

可以看到，索引项是按照索引定义里面出现的字段顺序排序的。

当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到 ID4，然后向后遍历得到所有需要的结果。

如果你要查的是所有名字第一个字是“张”的人，你的 SQL 语句的条件是"where name like ‘张 %’"。这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。

可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个**最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符**。

很显然，这里的（姓名，年龄）索引中的（姓名）是可以复用的，于是此处相当于拥有了两个索引，分别是：（姓名，年龄）、（姓名）

那么，**在建立联合索引的时候，如何安排索引内的字段顺序呢？**

1. 如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。  
    比如上面（姓名，年龄）的例子，通过建立（姓名，年龄），相当于拥有了（姓名，年龄）和（姓名）两个索引，不需要为（姓名）单独再创建一个索引。
2. 考虑字段大小，将字段大一点的排到前面去。  
    比如上面（姓名，年龄）的例子，如果还需要姓名跟年龄都建立索引，那么就应该建立（姓名，年龄）这样的联合索引，然后再建立一个（年龄）的索引。因为单独的（年龄）索引占用的空间比起单独的（姓名）的空间要来的小。

# 索引下推

> 在 MySQL5.6 以后引入了索引下推优化（index condition pushdown)。

还是拿上面（姓名，年龄）索引的例子，需求是这样的：检索出表中“名字第一个字是张，而且年龄是 10 岁的所有男孩”。

```sql
select * from tuser where name like '张%' and age=10 and is_male=1;
```

在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。

而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

> **无索引下推优化：**
> 
> 查找到第一个符合 `name like '张%'` 的记录，也就是 ID3 的张六，之后开始一个个回表对比其他字段值，**共需回表4次**。

> **有索引下推优化：**
> 
> 查找到第一个符合 `name like '张%'` 的记录，也就是 ID3 的张六，之后在（姓名，年龄）这棵索引树下直接判断是否符合 `age=10` 的条件，如果符合，则回表对比其他字段值；如果不符合，直接放弃回表，减少回表次数，**共需回表2次**。

---

> 网友热心总结的一些问题，复习的时候可以试着回答一下。
1. `select * from T where k betwee 3 and 5` 这条语句的执行流程是什么样的？
2. 回表的概念是什么？
3. 索引覆盖的概念是什么，索引覆盖的优点是什么？
4. 最左前缀原则的概念是什么？说明最左前缀原则的执行过程。
5. 索引下推的概念是什么？MySQL 5.6 的下推优化是怎么做的？ 

大家加油：）