---
title: MySQL实战：怎么选择普通索引和唯一索引？
abbrlink: 24920
date: 2022-06-15 17:21:22
description: 《极客时间-MySQL实战45讲》笔记整理。
categories: 
 - MySQL
---

# 查询操作下两个索引的不同

**普通索引的查询过程：**
> 对于普通索引的查询而言，查询到满足条件的第一条记录之后，还需要接着往下找，直到出现第一个不满足的记录。

**唯一索引的查询过程：**
> 对于唯一索引的查询而言，查询到满足条件的第一条记录之后，直接返回，不会再继续向下查找。

对于查询操作来说，普通索引和唯一索引的差别就是在命中第一条记录之后有没有一个往下继续比较的动作而已。显然，一个比较的动作对于性能的影响是微乎其微，可以忽略不计的，因此本文的重点也并不在此。

# change buffer

在 [【MySQL实战】深入浅出索引](https://www.wrp.cool/posts/42257/) 这篇文章中有提到过 MySQL 中的 `页` 的概念，页（Page）是 InnoDB 中管理数据的最小单元。

一个 `页` 中会存放很多条记录，不管是更新还是查找数据，都是要将 `页` 先读到内存当中的，然后在内存中更新数据，完了再把更新完的 `页` 写回磁盘。

可以看到在这个过程之中，存在着性能浪费。更新数据并不一定会更新到整个 `页` 中的数据，但是读数据到内存中却是将整个 `页` 的数据全部读取出来的，写回磁盘的过程也是将整个 `页` 的数据全部写回磁盘的。而读写磁盘都是非常昂贵的 IO 操作。于是在更新中肯定会有一些操作来避免或者是尽量的减少这样的 IO 浪费。

change buffer 就是这样的一种技术。

当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。

将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。

也就是说要尽量在 merge 的过程要刷越多的数据到磁盘上越好，在一个页上一次性刷的数据越多，反过来刷的次数就会越少，性能就会越高。

值得注意的是，change buffer 实际上它是可以持久化的数据。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。

{% note info %}
**change buffer 的使用：**
{% endnote %}

change buffer 用的是 buffer pool 里的内存，因此不能无限增大。change buffer 的大小，可以通过参数 innodb_change_buffer_max_size 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。

# 更新操作下两个索引的不同

第一种情况是，**这个记录要更新的目标页在内存中。**这时，InnoDB 的处理流程如下：
- 对于唯一索引来说，找到待更新的位置，判断到没有冲突，插入这个值，语句执行结束；
- 对于普通索引来说，找到待更新的位置，插入这个值，语句执行结束。
这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU 时间。但，这不是我们关注的重点。

第二种情况是，**这个记录要更新的目标页不在内存中。**这时，InnoDB 的处理流程如下：

- 对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；
- 对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。

将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。

> 对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。因此，唯一索引的更新就不能使用 change buffer，**实际上也只有普通索引可以使用**。

# 比较 change buffer 和 redo log 的差别

{% note info %}
**以写为例，change buffer 的工作流程：**
{% endnote %}

1. 待更新数据页在内存中，直接更新内存中的数据页。记录 redo log。
2. 待更新数据页不在内存中，在内存的 change buffer 区域记录下“我要在数据页X中更新一条数据”。记录 redo log。

这样的操作执行成本其实很低，不论数据页是否在内存中，都是写一次内存，然后再写一次磁盘（顺序写）。比起直接去磁盘更新对应数据性能要好一些。

{% note info %}
**以读为例，change buffer 的工作流程：**
{% endnote %}

1. 要读取的数据页在内存中，直接返回对应结果。
2. 要读取的数据页不在内存中，将对应的数据页读取到内存中，再应用 change buffer 里面的操作日志，生成对应的结果返回。

> 值得注意的是：更新操作写完 redo log 之后，如果此时需要马上读取这部分数据，并不需要立即更新 redo log 中的数据到数据页中，可以读取对应数据页之后应用 change buffer 日志返回正确结果。

--- 

OK，最后回到本文主题：**普通索引和唯一索引，应该怎么选择？**

如果在业务上可以接受，首先建议选择普通索引，因为可以应用 change buffer 的优化。