---
title: MySQL实战：全局锁、表锁、行锁
abbrlink: 27299
date: 2022-06-05 15:32:24
description: 《极客时间-MySQL实战45讲》笔记整理。
categories: 
 - MySQL
---

> - [《极客时间-MySQL实战45讲》06 | 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？](https://time.geekbang.org/column/article/69862)
> - [《极客时间-MySQL实战45讲》07 | 行锁功过：怎么减少行锁对性能的影响？](https://time.geekbang.org/column/article/70215)
> - 笔记整理

<!-- more -->

根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。

在正式开篇之前还是得先搞清楚两个概念：共享锁和排他锁

- **共享锁：**所有线程都可以拥有共享锁，故名为共享。一般是读锁。
- **排他锁：**仅一个线程可以拥有锁，其他线程必须等待该线程释放锁后才可以拿到锁，故名为排他。一般是写锁。

---

# 全局锁

> 顾名思义，全局锁的锁定对象是整个数据库实例。

- **加锁语法：**`flush tables with read lock; (FTWRL)`
- **释放锁语法：**`unlock tables;`

这是一把读锁，使用之后所有的线程只能读取数据而不能修改数据，方式是阻塞其他线程的以下一些语句：
- 数据更新语句（数据的增删改）
- 数据定义语句（包括建表、修改表结构等）
- 更新类事务的提交语句。

比较多的使用场景是全局逻辑备份，**用于保证备份时的数据一致性**。其底层支持是 [MVCC 多版本并发控制](https://www.wrp.cool/posts/574/)

> 在备份的场景里，FTWRL 相较于 `set global read_only=true;` 的优势：

1. readonly 的值可能会被用来做其他逻辑，比如用来判断一个库是主库还是备库。影响面比较大，不建议使用。
2. 异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。

> **MySQL 全局备份方式：**
> 官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数 `–single-transaction` 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。
>
> **注意：**
> MySQL 并非所有的引擎都支持 `–single-transaction` 参数，底层需要 MVCC 的支持，而目前仅 InnoDB 提供了 MVCC 支持。如果有的表使用了不支持事务的引擎，那么备份就只能通过 FTWRL 方法。这往往是 DBA 要求业务开发人员使用 InnoDB 替代 MyISAM 的原因之一。

# 表级锁

MySQL5.5 开始引入了元数据锁，自此MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。

## 表锁

> 用于锁定整个表对象，分为读锁和写锁。

读锁（ `lock tables … read`）：该锁是一种**共享锁**，MySQL 中的表一旦被加上了读锁，其他线程的修改语句就会被阻塞。所有线程均仅可读。
写锁（ `lock tables … write`）：该锁是一种**排他锁**，MySQL 中的表一旦被加上了写锁，除了拥有锁的线程之外，其他的线程对该表的读写操作都会被阻塞。

{%note danger%}
对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面太大了。
{%endnote%}

## 元数据锁（meta data lock，MDL）

> 这是一种列锁，锁住的是表的表结构。也就是说上锁期间会对 DDL 的操作做限制。同样分为了 MDL 读锁和 MDL 写锁。

MDL 是 server 层的锁，表级锁，主要用于隔离 DML 和 DDL 操作之间的干扰。每执行一条 DML、DDL 语句时都会申请 MDL锁，DML 操作需要 MDL 读锁（共享），DDL 操作需要 MDL 写锁（排他）。MDL 加锁过程是系统自动控制，无法直接干预。

{%note danger%}
MDL 可能导致线程爆满，打爆数据库系统。
{%endnote%}

![MDL阻塞过程演示图](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/MDL阻塞过程演示图.jpg)

在上面的这个图中，sessionA 正常启动，正常获取 MDL 读锁，之后 sessionB 启动，也获取到 MDL 读锁。

之后 sessionC 启动需要获取 MDL 写锁，此时由于 MDL 读锁还没释放，于是 sessionC 进入阻塞状态等待获取 MDL 写锁。

但是如果碰巧 sessionA 或者 sessionB 中有一个是长事务，那么 sessionC 被阻塞的时间就会久一些，sessionC 之后的所有线程都拿不到 MDL 锁，不论是 MDL 读锁还是 MDL 写锁都拿不到。

如果此时恰巧有很多的请求进来，全部都被阻塞在一起，很快就会导致线程爆满，数据库被打爆。

# 行锁

> 顾名思义，行锁就是针对数据表中行记录的锁。这很好理解，比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。

## 行锁的两阶段协议

{%note default%}
举例说明：
{%endnote%}

![行锁-两阶段协议](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/行锁-两阶段协议.jpg)

在这个例子中，事务B会被事务A阻塞，直到事务A commit 才会执行事务B。显然事务A持有 id=1、id=2 这两行的锁。

> 可以得出：
>
> 在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。
> **这个就是两阶段锁协议。**

由两阶段协议可得：

{%note warning%}
**如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。**
{%endnote%}

> **像这样：**
>
> 假设你负责实现一个电影票在线交易业务，顾客 A 要在影院 B 购买电影票。我们简化一点，这个业务需要涉及到以下操作：
> 1. 从顾客 A 账户余额中扣除电影票价；
> 2. 给影院 B 的账户余额增加这张电影票价；
> 3. 记录一条交易日志。
> 
> 由于两阶段协议，所以应该尽量把最可能造成锁冲突、影响并发度的锁往后放。
> 所以以上三条语句在编码时的执行顺序应该是：`1 3 2` 或者是 `3 1 2`

## 死锁和死锁检测

> **什么是死锁：**
>
> 当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。

{%note default%}
**举例：**
{%endnote%}

![拿行锁举个死锁例子](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/拿行锁举个死锁例子.jpg)

此时，事务A在等待事务B中 id=2 的行锁，事务B又在等待事务A id=1 的锁，陷入了一种事务A等事务B，事务B等事务A的状态，这就是死锁现象。

{%note primary%}
**死锁的应对策略：**
{%endnote%}

1. 直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。
    在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s，对于在线服务来说，这个等待时间往往是无法接受的。但是如果把这个超时时间设置的很短呢？那又可能误伤到很多只是锁等待的线程，这也不好。所以这个方案需要把握好一个比较精准的度。

2. 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。
    
> 正常情况下我们还是要采用第二种策略，即：**主动死锁检测**，而且 innodb_deadlock_detect 的默认值本身就是 on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。
> 
> 你可以想象一下这个过程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。
> 
> 但是如果很大量的请求都要同时更新同一行的数据呢？
> 
> 每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。

{% note primary %}
**怎么解决由这种热点性更新导致的性能问题呢？**
{% endnote %}

1. 在业务上保证不出现死锁的情况，将死锁检测关掉。
    - **缺点：**业务上的实现很困难
2. 控制并发度。
    - **怎么做？**借助中间件，或者是直接修改 MySQL 源码。
3. 从数据库设计上优化。
    - **怎么做？**将一条数据扩展成多条数据，每次随机选择其中一条记录来做修改，人为的将并发度降低。

---

> 网友热心总结的一些问题，复习的时候可以试着回答一下。

1. MySQL从加锁范围上分为哪三类?
2. 全局锁加锁方法的执行命令是什么?主要的应用场景是什么?
3. 做整库备份时为什么要加全局锁?
4. MySQL的自带备份工具, 使用什么参数可以确保一致性视图, 在什么场景下不适用?
5. 不建议使用set global readonly = true的方法加全局锁有哪两点原因?
6. 表级锁有哪两种类型?  各自的使用场景是什么?
7. MDL中读写锁之间的互斥关系怎样的?
8. 如何安全的给小表增加字段?
9. 两阶段锁的概念是什么? 对事务使用有什么帮助?
10. 死锁的概念是什么? 举例说明出现死锁的情况.
11. 死锁的处理策略有哪两种? 
12. 等待超时处理死锁的机制什么?有什么局限?
13. 死锁检测处理死锁的机制是什么? 有什么局限?
14. 有哪些思路可以解决热点更新导致的并发问题?