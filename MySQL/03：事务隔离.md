---
title: MySQL实战：事务隔离
abbrlink: 574
date: 2022-06-03 14:27:10
description: 《极客时间-MySQL实战45讲》笔记整理。
categories: 
 - MySQL
---

> - [《极客时间-MySQL实战45讲》03 | 事务隔离：为什么你改了我还看不见？](https://time.geekbang.org/column/article/68963)
> - [《极客时间-MySQL实战45讲》08 | 事务到底是隔离还是不隔离的？](https://time.geekbang.org/column/article/70562)
> - 笔记整理

<!-- more -->

# 事务的基本特性（ACID）

- **原子性（Atomicity）：**事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。
- **一致性（Consistency）：**事务开始前和结束后，数据库的完整性约束没有被破坏。
- **隔离性（Isolation）：**同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。
- **持久性（Durability）：**事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。

# 不考虑隔离性可能产生的问题

- **脏读：**指在一个事务处理过程中读取了另一个未提交的事务中的数据。
    - 比如事务A将 x 的值从0修改为1，但未回滚或提交，此时事务B读取了 x 的值为1，随后事务A回滚，将 x 的值重新设置为0。那么事务B读取的 x 的值为1的哪个过程就称为脏读。
- **不可重复读：**一个事务内多次查询**同一个数据**却返回了不同的数据值。
    - 比如事务A查询 x 值为0，此时事务B将 x 的值修改为0并提交，事务A再次查询 x 的值为1。事务A并未对 x 的值做操作，但是两次查询 x 的值发生了变化，这个现象就被称为不可重复读。
- **幻读：**一个事务内多次查询**同一批数据**却返回了不同批的数据。
    - 比如事务A查询用户表有100个用户，此时事务B新增或者删除了一些用户，之后事务A再次查询用户表返回的不是100个用户。这个现象就被称为幻读。

> 幻读和不可重复读看起来好像很相似，都是读取了另外一个事务所提交的修改，但区别是**不可重复读针对的是数据项，而幻读针对的是数据量**。

# 事务隔离级别

- **读未提交（READ UNCOMMITTED）：**一个事务还没提交时，它做的变更就能被别的事务看到。
- **读已提交（READ COMMITTED）：**一个事务提交之后，它做的变更才会被其他事务看到。
- **可重复读（REPEATABLE READ）：**一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。
- **串行化（SERIALIZABLE ）：**顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

![事务隔离级别举例](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/事务隔离级别举例.jpg)

- **读未提交：** V1 的值是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。
- **读已提交：** V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以，V3 的值也是 2。
- **可重复读：** V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。
- **串行化：**在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。

# 事务隔离的实现

事务隔离级别中的 READ UNCOMMITIED 总是读取最新的数据行，而不是符合当前事务版本的数据行。而 SERIALIZABLE 则会对所有读取的行都加锁。这两种隔离级别都能够独立实现，而 READ COMMITTED 和 REPEATABLE READ 这两种隔离级别则需要依赖于 MVVC 多版本并发控制来实现。

{% note primary %}
**MVCC 多版本并发控制**
{% endnote %}

**什么是 MVCC？**
 
> MVCC，全称 Multi-Version Concurrency Control，即多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。

**MVCC 能做什么？**
> 借助 MVCC 实现了 READ COMMITTED，REPEATABLE READ 等隔离级别。

# InnoDB 中的 MVCC

InnDB 中每个事务都有一个唯一的事务 ID，记为 transaction_id。它在事务开始时向 InnDB 申请，按照时间先后严格递增。

而每行数据其实都有多个版本，这就依赖 undo log 来实现了。每次事务更新数据就会生成一个新的数据版本，并把  transaction_id 记为 row trx_id。同时旧的数据版本会保留在 undo log 中，而且新的版本会记录旧版本的回滚指针，通过它直接拿到上一个版本。

为了保证每个事务中拿到的数据都是不被其他事务污染的，InnoDB 还需要一个 read-view（一致性读视图） 来保存每次事务查询的时候不被污染的那一份数据。

所以，InnDB 中的 MVCC 其实是通过在每行记录后面保存两个隐藏的列来实现的。一列是事务 ID：`trx_id`；另一列是回滚指针：`roll_pt`。

## undo log（回滚日志）

回滚日志保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。

根据操作和删除日志时机的不同，undo log 分为两种： insert undo log 和 update undo log。

### insert undo log

由于 INSERT 操作记录没有历史版本只对当前事务本身可见，对于其他事务此记录不可见，所以 insert undo log 可以在事务提交后直接删除而不需要进行 purge 操作。

> purge（清除）：的主要任务是将数据库中已经 mark del 的数据删除，另外也会批量回收 undo pages

在事务提交时，这个事务所做的 INSERT 的操作所记录的 undo log 的日志会被直接删除。

### update undo log

由于 UPDATE 操作的历史版本可能其他的事务需要用到，所以 UPDATE 操作的 undo log 保存的时间会长一些，只有在系统中没有比这个回滚日志更早的版本时，purge 线程将进行最后的删除操作。

假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。

![回滚日志流程图](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/回滚日志流程图.jpg)

如果发生了回滚，4就会变成3再变成2再变成1，一步一步的恢复到初始状态。

> 当不需要这些回滚日志的时候，这些日志就会被删除。
> 什么时候不需要这些回滚日志呢？**当系统里没有比这个回滚日志更早的 read-view 的时候。**

![1654328337012](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/1654328337012.png)

## read-view（一致性读视图）

read view 是 InnDB 在实现 MVCC 时用到的一致性读视图，用于支持 RC（读提交）以及 RR（可重复读）隔离级别的实现。

read view 不是真实存在的，只是一个概念，undo log 才是它的实现，**主要是通过版本和 undolog 计算出来的**，作用是决定事务能看到哪些数据。

每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据 row trx_id 和一致性视图确定数据版本的可见性。

{% note warning %}
**可见性规则**
{% endnote %}

> 一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。

在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。

数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。（注意：低水位是数组内最小值，高水位是系统内最大的事务ID再加1，高水位不在数组内）

这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。而数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的。

{% note primary %}
**这个视图数组把所有的 row trx_id 分成了几种不同的情况，如下：**
{% endnote %}

1. **小于低水位：**表示这个版本是已提交的事务，这个数据是可见的；
2. **大于等于高水位：**表示这个版本是由将来启动的事务生成的，是肯定不可见的；
3. **大于等于低水位 && 小于高水位：**
    - **就是当前事务：**可见；
    - **row trx_id 在数组中：**表示这个版本是由还没提交的事务生成的，不可见；
    - **row trx_id 不在数组中：**表示这个版本是已经提交了的事务生成的，可见。

> 关于第三点的 row trx_id 在不在数组中，不是很好理解，专门画了个图：

![MVCC水位图](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/MVCC水位图.png)

{% note info %}
**一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：**
{% endnote %}

1. 版本未提交，不可见；
2. 版本已提交，但是是在视图创建后提交的，不可见；
3. 版本已提交，而且是在视图创建前提交的，可见。

# 更新不用 read-view

{% note danger %}
**更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）**
{% endnote %}

> **为什么 UPDATE 操作必须使用当前读？**
>
> 当 `x=1` 事务A 执行：`set x = x + 1`；事务B 也执行：`set x = x + 1`。
> **一致性读：**
>   - 事务A 与 事务B 拿到 x 的初始数据都是 x=1，执行完毕后 x=2，**丢失其中一次更新**
>
> **当前读：**
>   - 事务A 开始执行。事务B 等待 事务A 执行完毕
>   - 事务A 执行完毕，x=2。事务B 开始执行，x=3
>
> **可见当前读未丢失更新**

{% note success %}
**这也是行锁的两阶段协议存在的原因，防止更新丢失。**
{% endnote %}

{% note primary %}
**除了 update 语句外，select 语句如果加锁，也是当前读。**
{% endnote %}

# 一个例子结束本文

假设现在有一个表 t，初始化语句如下：
```sql
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `k` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t(id, k) values(1,1),(2,2);
```

此时，分别有事务A、事务B、事务C，执行流程如下：

![事务举例](https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/事务举例.jpg)

**注意：**begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令。

- 第一种启动方式，一致性视图是在执行第一个快照读语句时创建的；
- 第二种启动方式，一致性视图是在执行 start transaction with consistent snapshot 时创建的。

**但是：**在读提交的隔离级别下，“start transaction with consistent snapshot; ”这个用法就没意义了，等效于普通的 start transaction。

**因为：**在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。

> 本例中，事务A、事务B、事务C分别的查询结果：
> - **事务A**读取的 k = 1：事务A 的一致性视图开启时 k = 1。
> - **事务B**读取的 k = 3：事务B 的更新采用当前读，当前 k 值已经被事务C修改成2。
> - **事务C**读取的 k = 1：事务C 最初始拿到的 k 值就是1。

---
大家加油：）